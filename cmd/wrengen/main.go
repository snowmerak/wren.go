package main

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"log"
	"os"
	"path/filepath"
	"regexp"
	"strings"
	"text/template"
)

type ModuleInfo struct {
	ModuleName string
	Classes    []ClassInfo
}

type ClassInfo struct {
	ClassName string
	Methods   []MethodInfo
}

type MethodInfo struct {
	GoName     string
	WrenName   string
	IsStatic   bool
	Signature  string
	Index      int
}

func main() {
	if len(os.Args) < 3 || os.Args[1] != "-dir" {
		log.Fatal("Usage: wrengen -dir <directory>")
	}

	dir := os.Args[2]
	modules := parseBuiltinDirectory(dir)
	
	if len(modules) == 0 {
		fmt.Println("No modules found")
		return
	}

	generateBuiltinWren(modules)
	fmt.Printf("Generated builtin_wren.go with %d modules\n", len(modules))
}

func parseBuiltinDirectory(dir string) []ModuleInfo {
	var modules []ModuleInfo
	
	err := filepath.Walk(dir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}
		
		if !strings.HasSuffix(path, ".go") || strings.HasSuffix(path, "_test.go") {
			return nil
		}
		
		module := parseGoFile(path)
		if module != nil {
			modules = append(modules, *module)
		}
		
		return nil
	})
	
	if err != nil {
		log.Fatal(err)
	}
	
	return modules
}

func parseGoFile(filename string) *ModuleInfo {
	fset := token.NewFileSet()
	node, err := parser.ParseFile(fset, filename, nil, parser.ParseComments)
	if err != nil {
		log.Printf("Error parsing %s: %v", filename, err)
		return nil
	}
	
	var module ModuleInfo
	var currentClass ClassInfo
	methodIndex := 0
	
	ast.Inspect(node, func(n ast.Node) bool {
		switch x := n.(type) {
		case *ast.TypeSpec:
			if x.Doc != nil {
				moduleComment := extractComment(x.Doc.Text())
				if moduleName := extractModuleName(moduleComment); moduleName != "" {
					module.ModuleName = moduleName
					currentClass.ClassName = x.Name.Name
				}
			}
		case *ast.FuncDecl:
			if x.Doc != nil && x.Recv != nil {
				comment := extractComment(x.Doc.Text())
				if methodInfo := parseMethodComment(comment, x.Name.Name, methodIndex); methodInfo != nil {
					currentClass.Methods = append(currentClass.Methods, *methodInfo)
					methodIndex++
				}
			}
		}
		return true
	})
	
	if module.ModuleName != "" && len(currentClass.Methods) > 0 {
		module.Classes = []ClassInfo{currentClass}
		return &module
	}
	
	return nil
}

func extractComment(text string) string {
	lines := strings.Split(text, "\n")
	var result []string
	for _, line := range lines {
		line = strings.TrimSpace(line)
		if strings.HasPrefix(line, "//") {
			result = append(result, strings.TrimSpace(line[2:]))
		}
	}
	return strings.Join(result, "\n")
}

func extractModuleName(comment string) string {
	re := regexp.MustCompile(`wren:bind\s+module=(\w+)`)
	matches := re.FindStringSubmatch(comment)
	if len(matches) > 1 {
		return matches[1]
	}
	return ""
}

func parseMethodComment(comment, goName string, index int) *MethodInfo {
	re := regexp.MustCompile(`wren:bind\s+name=([^\s]+)(?:\s+(static))?`)
	matches := re.FindStringSubmatch(comment)
	if len(matches) > 1 {
		return &MethodInfo{
			GoName:    goName,
			WrenName:  matches[1],
			IsStatic:  len(matches) > 2 && matches[2] == "static",
			Signature: matches[1],
			Index:     index,
		}
	}
	return nil
}

func generateBuiltinWren(modules []ModuleInfo) {
	tmpl := `// Code generated by wrengen. DO NOT EDIT.

package wrengo

import (
	"github.com/snowmerak/wren.go/builtin"
)

func init() {
	{{range $module := .}}{{range $class := $module.Classes}}{{range $method := $class.Methods}}
	RegisterForeignMethod("{{$module.ModuleName}}", "{{$class.ClassName}}", {{$method.IsStatic}}, "{{$method.Signature}}", wrengoForeignMethod_{{$method.Index}}){{end}}{{end}}{{end}}
}

{{range $module := .}}{{range $class := $class.Classes}}{{range $method := $class.Methods}}
//export wrengoForeignMethod_{{$method.Index}}
func wrengoForeignMethod_{{$method.Index}}(vm *WrenVM) {
	{{if eq $module.ModuleName "async"}}async := &builtin.Async{}
	async.{{$method.GoName}}(vm){{else if eq $module.ModuleName "math"}}math := &builtin.Math{}
	math.{{$method.GoName}}(vm){{else if eq $module.ModuleName "strings"}}strings := &builtin.StringUtils{}
	strings.{{$method.GoName}}(vm){{end}}
}{{end}}{{end}}{{end}}
`
	
	t, err := template.New("builtin").Parse(tmpl)
	if err != nil {
		log.Fatal(err)
	}
	
	file, err := os.Create("builtin_wren.go")
	if err != nil {
		log.Fatal(err)
	}
	defer file.Close()
	
	err = t.Execute(file, modules)
	if err != nil {
		log.Fatal(err)
	}
}