package main

import (
	"bufio"
	"fmt"
	"log"
	"os"
	"path/filepath"
	"regexp"
	"sort"
	"strings"
	"text/template"
)

type ModuleInfo struct {
	ModuleName string
	ClassName  string
	Methods    []MethodInfo
}

type MethodInfo struct {
	GoName    string
	WrenName  string
	IsStatic  bool
	Signature string
	Index     int
}

func main() {
	if len(os.Args) < 3 || os.Args[1] != "-dir" {
		log.Fatal("Usage: wrengen -dir <directory>")
	}

	dir := os.Args[2]
	modules := parseBuiltinDirectory(dir)

	if len(modules) == 0 {
		fmt.Println("No modules found")
		return
	}

	generateBuiltinWren(modules)
	fmt.Printf("Generated builtin_wren.go with %d modules\n", len(modules))
}

func parseBuiltinDirectory(dir string) []ModuleInfo {
	var modules []ModuleInfo

	err := filepath.Walk(dir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		if !strings.HasSuffix(path, ".go") || strings.HasSuffix(path, "_test.go") {
			return nil
		}

		module := parseGoFile(path)
		if module != nil {
			modules = append(modules, *module)
		}

		return nil
	})

	if err != nil {
		log.Fatal(err)
	}

	return modules
}

func parseGoFile(filename string) *ModuleInfo {
	file, err := os.Open(filename)
	if err != nil {
		log.Printf("Error opening %s: %v", filename, err)
		return nil
	}
	defer file.Close()

	var module ModuleInfo
	var methods []MethodInfo
	methodIndex := 0

	scanner := bufio.NewScanner(file)
	var commentBlock []string

	for scanner.Scan() {
		line := strings.TrimSpace(scanner.Text())

		// Collect comment lines
		if strings.HasPrefix(line, "//") {
			commentBlock = append(commentBlock, line)
			continue
		}

		// Check for type declaration (module)
		if strings.HasPrefix(line, "type ") && strings.Contains(line, "struct{}") {
			moduleComment := strings.Join(commentBlock, "\n")
			if moduleName := extractModuleName(moduleComment); moduleName != "" {
				module.ModuleName = moduleName
				// Extract class name from type declaration
				re := regexp.MustCompile(`type\s+(\w+)\s+struct`)
				matches := re.FindStringSubmatch(line)
				if len(matches) > 1 {
					module.ClassName = matches[1]
				}
			}
		}

		// Check for function declaration
		if strings.HasPrefix(line, "func (") && strings.Contains(line, ") ") {
			commentContent := strings.Join(commentBlock, "\n")
			if methodInfo := parseMethodComment(commentContent, line, methodIndex); methodInfo != nil {
				methods = append(methods, *methodInfo)
				methodIndex++
			}
		}

		// Reset comment block if we hit a non-comment line
		if !strings.HasPrefix(line, "//") && line != "" {
			commentBlock = nil
		}
	}

	if err := scanner.Err(); err != nil {
		log.Printf("Error reading %s: %v", filename, err)
		return nil
	}

	if module.ModuleName != "" && len(methods) > 0 {
		module.Methods = methods
		return &module
	}

	return nil
}

func extractModuleName(comment string) string {
	re := regexp.MustCompile(`wren:bind\s+module=(\w+)`)
	matches := re.FindStringSubmatch(comment)
	if len(matches) > 1 {
		return matches[1]
	}
	return ""
}

func parseMethodComment(comment, funcLine string, index int) *MethodInfo {
	// Extract function name from function declaration
	re := regexp.MustCompile(`func\s+\([^)]+\)\s+(\w+)\(`)
	funcMatches := re.FindStringSubmatch(funcLine)
	if len(funcMatches) < 2 {
		return nil
	}
	goName := funcMatches[1]

	// Parse wren:bind comment
	bindRe := regexp.MustCompile(`wren:bind\s+name=([^\s]+)(?:\s+(static))?`)
	bindMatches := bindRe.FindStringSubmatch(comment)
	if len(bindMatches) < 2 {
		return nil
	}

	return &MethodInfo{
		GoName:    goName,
		WrenName:  bindMatches[1],
		IsStatic:  len(bindMatches) > 2 && bindMatches[2] == "static",
		Signature: bindMatches[1],
		Index:     index,
	}
}

func generateBuiltinWren(modules []ModuleInfo) {
	// Sort modules by name for consistent output
	sort.Slice(modules, func(i, j int) bool {
		return modules[i].ModuleName < modules[j].ModuleName
	})

	// Assign global indices to methods across all modules
	globalIndex := 0
	for i := range modules {
		for j := range modules[i].Methods {
			modules[i].Methods[j].Index = globalIndex
			globalIndex++
		}
	}

	tmpl := `// Code generated by wrengen. DO NOT EDIT.

package main

import (
	wrengo "github.com/snowmerak/gwen"
	"github.com/snowmerak/gwen/builtin"
)

func init() {
{{range $module := .}}	// Register {{$module.ModuleName}} module
{{range $method := $module.Methods}}	wrengo.RegisterForeignMethod("{{$module.ModuleName}}", "{{$module.ClassName}}", {{$method.IsStatic}}, "{{$method.Signature}}", wrengoForeignMethod_{{$method.Index}})
{{end}}
{{end}}}

{{range $module := .}}// {{$module.ClassName}} module methods
{{range $method := $module.Methods}}//export wrengoForeignMethod_{{$method.Index}}
func wrengoForeignMethod_{{$method.Index}}(vm *wrengo.WrenVM) {
	{{$module.ModuleName}} := &builtin.{{$module.ClassName}}{}
	{{$module.ModuleName}}.{{$method.GoName}}(vm)
}

{{end}}{{end}}`

	t, err := template.New("builtin").Parse(tmpl)
	if err != nil {
		log.Fatal(err)
	}

	file, err := os.Create("cmd/gwen/builtin_wren.go")
	if err != nil {
		log.Fatal(err)
	}
	defer file.Close()

	err = t.Execute(file, modules)
	if err != nil {
		log.Fatal(err)
	}
}
