package main

import (
	"bufio"
	"fmt"
	"log"
	"os"
	"path/filepath"
	"regexp"
	"sort"
	"strings"
)

type ModuleInfo struct {
	ModuleName string
	ClassName  string
	Methods    []MethodInfo
}

type MethodInfo struct {
	GoName     string
	WrenName   string
	IsStatic   bool
	Signature  string
	Doc        string
}

func main() {
	if len(os.Args) < 2 {
		log.Fatal("Usage: wrenlsp-gen <builtin_wren.go>")
	}

	builtinWrenFile := os.Args[1]
	modules := parseBuiltinWrenFile(builtinWrenFile)
	
	generateLSPBuiltins(modules)
	fmt.Printf("Generated LSP builtins with %d modules\n", len(modules))
}

func parseBuiltinWrenFile(filename string) []ModuleInfo {
	file, err := os.Open(filename)
	if err != nil {
		log.Fatal(err)
	}
	defer file.Close()

	moduleMap := make(map[string]*ModuleInfo)
	scanner := bufio.NewScanner(file)

	for scanner.Scan() {
		line := strings.TrimSpace(scanner.Text())
		
		// Look for RegisterForeignMethod calls
		if strings.Contains(line, "RegisterForeignMethod") {
			if module := parseRegisterCall(line); module != nil {
				key := module.ModuleName + "_" + module.ClassName
				if existing, exists := moduleMap[key]; exists {
					existing.Methods = append(existing.Methods, module.Methods[0])
				} else {
					moduleMap[key] = module
				}
			}
		}
	}

	// Convert map to slice and sort
	var modules []ModuleInfo
	for _, module := range moduleMap {
		sort.Slice(module.Methods, func(i, j int) bool {
			return module.Methods[i].WrenName < module.Methods[j].WrenName
		})
		modules = append(modules, *module)
	}
	
	sort.Slice(modules, func(i, j int) bool {
		return modules[i].ModuleName < modules[j].ModuleName
	})

	return modules
}

func parseRegisterCall(line string) *ModuleInfo {
	// Parse: wrengo.RegisterForeignMethod("async", "Async", true, "sleep(_)", wrengoForeignMethod_0)
	re := regexp.MustCompile(`RegisterForeignMethod\("([^"]+)",\s*"([^"]+)",\s*(true|false),\s*"([^"]+)"`)
	matches := re.FindStringSubmatch(line)
	
	if len(matches) != 5 {
		return nil
	}

	return &ModuleInfo{
		ModuleName: matches[1],
		ClassName:  matches[2],
		Methods: []MethodInfo{
			{
				WrenName:  extractMethodName(matches[4]),
				Signature: matches[4],
				IsStatic:  matches[3] == "true",
				Doc:       generateDoc(matches[1], matches[2], matches[4]),
			},
		},
	}
}

func extractMethodName(signature string) string {
	// Extract method name from signature like "sleep(_)" -> "sleep"
	idx := strings.Index(signature, "(")
	if idx == -1 {
		return signature
	}
	return signature[:idx]
}

func generateDoc(module, class, signature string) string {
	methodName := extractMethodName(signature)
	return fmt.Sprintf("%s method from %s.%s class.", methodName, module, class)
}

func generateLSPBuiltins(modules []ModuleInfo) {
	// Get the output path relative to the working directory
	wd, err := os.Getwd()
	if err != nil {
		log.Fatal(err)
	}
	
	outputPath := filepath.Join(wd, "wrenlsp", "builtins_generated.go")
	
	file, err := os.Create(outputPath)
	if err != nil {
		log.Fatal(err)
	}
	defer file.Close()

	// Write header and core classes
	fmt.Fprintln(file, `// Code generated by wrenlsp-gen. DO NOT EDIT.

package wrenlsp

// Built-in Wren classes and methods from wren.go builtin modules
var builtinSymbols = []ForeignMethodInfo{
	// Core Wren classes (manually maintained)
	{
		Module:    "core",
		Class:     "System",
		Method:    "print",
		Signature: "print(_)",
		IsStatic:  true,
		Doc:       "Prints the value to stdout.",
	},
	{
		Module:    "core",
		Class:     "System",
		Method:    "write",
		Signature: "write(_)",
		IsStatic:  true,
		Doc:       "Writes the value to stdout without a newline.",
	},
	{
		Module:    "core",
		Class:     "System",
		Method:    "clock",
		Signature: "clock",
		IsStatic:  true,
		Doc:       "Returns the number of seconds since the program started.",
	},
	{
		Module:    "core",
		Class:     "System",
		Method:    "gc",
		Signature: "gc()",
		IsStatic:  true,
		Doc:       "Runs the garbage collector.",
	},

	// Fiber class
	{
		Module:    "core",
		Class:     "Fiber",
		Method:    "new",
		Signature: "new(_)",
		IsStatic:  true,
		Doc:       "Creates a new fiber that executes the given function.",
	},
	{
		Module:    "core",
		Class:     "Fiber",
		Method:    "yield",
		Signature: "yield()",
		IsStatic:  true,
		Doc:       "Yields control from the current fiber.",
	},
	{
		Module:    "core",
		Class:     "Fiber",
		Method:    "call",
		Signature: "call()",
		IsStatic:  false,
		Doc:       "Runs the fiber.",
	},

	// List class
	{
		Module:    "core",
		Class:     "List",
		Method:    "add",
		Signature: "add(_)",
		IsStatic:  false,
		Doc:       "Adds an item to the end of the list.",
	},
	{
		Module:    "core",
		Class:     "List",
		Method:    "clear",
		Signature: "clear()",
		IsStatic:  false,
		Doc:       "Removes all items from the list.",
	},
	{
		Module:    "core",
		Class:     "List",
		Method:    "count",
		Signature: "count",
		IsStatic:  false,
		Doc:       "The number of items in the list.",
	},
	{
		Module:    "core",
		Class:     "List",
		Method:    "insert",
		Signature: "insert(_,_)",
		IsStatic:  false,
		Doc:       "Inserts an item at the given index.",
	},
	{
		Module:    "core",
		Class:     "List",
		Method:    "iterate",
		Signature: "iterate(_)",
		IsStatic:  false,
		Doc:       "Returns the next iterator value.",
	},
	{
		Module:    "core",
		Class:     "List",
		Method:    "iteratorValue",
		Signature: "iteratorValue(_)",
		IsStatic:  false,
		Doc:       "Returns the value at the iterator position.",
	},
	{
		Module:    "core",
		Class:     "List",
		Method:    "removeAt",
		Signature: "removeAt(_)",
		IsStatic:  false,
		Doc:       "Removes the item at the given index.",
	},

	// Map class
	{
		Module:    "core",
		Class:     "Map",
		Method:    "clear",
		Signature: "clear()",
		IsStatic:  false,
		Doc:       "Removes all entries from the map.",
	},
	{
		Module:    "core",
		Class:     "Map",
		Method:    "containsKey",
		Signature: "containsKey(_)",
		IsStatic:  false,
		Doc:       "Returns true if the map contains the given key.",
	},
	{
		Module:    "core",
		Class:     "Map",
		Method:    "count",
		Signature: "count",
		IsStatic:  false,
		Doc:       "The number of entries in the map.",
	},
	{
		Module:    "core",
		Class:     "Map",
		Method:    "iterate",
		Signature: "iterate(_)",
		IsStatic:  false,
		Doc:       "Returns the next iterator value.",
	},
	{
		Module:    "core",
		Class:     "Map",
		Method:    "iteratorValue",
		Signature: "iteratorValue(_)",
		IsStatic:  false,
		Doc:       "Returns the value at the iterator position.",
	},
	{
		Module:    "core",
		Class:     "Map",
		Method:    "keys",
		Signature: "keys",
		IsStatic:  false,
		Doc:       "Returns a list of all keys in the map.",
	},
	{
		Module:    "core",
		Class:     "Map",
		Method:    "remove",
		Signature: "remove(_)",
		IsStatic:  false,
		Doc:       "Removes the entry with the given key.",
	},
	{
		Module:    "core",
		Class:     "Map",
		Method:    "values",
		Signature: "values",
		IsStatic:  false,
		Doc:       "Returns a list of all values in the map.",
	},

	// String class
	{
		Module:    "core",
		Class:     "String",
		Method:    "contains",
		Signature: "contains(_)",
		IsStatic:  false,
		Doc:       "Returns true if the string contains the given substring.",
	},
	{
		Module:    "core",
		Class:     "String",
		Method:    "count",
		Signature: "count",
		IsStatic:  false,
		Doc:       "The number of characters in the string.",
	},
	{
		Module:    "core",
		Class:     "String",
		Method:    "startsWith",
		Signature: "startsWith(_)",
		IsStatic:  false,
		Doc:       "Returns true if the string starts with the given prefix.",
	},
	{
		Module:    "core",
		Class:     "String",
		Method:    "endsWith",
		Signature: "endsWith(_)",
		IsStatic:  false,
		Doc:       "Returns true if the string ends with the given suffix.",
	},

	// Num class
	{
		Module:    "core",
		Class:     "Num",
		Method:    "abs",
		Signature: "abs",
		IsStatic:  false,
		Doc:       "Returns the absolute value.",
	},
	{
		Module:    "core",
		Class:     "Num",
		Method:    "ceil",
		Signature: "ceil",
		IsStatic:  false,
		Doc:       "Returns the smallest integer >= this number.",
	},
	{
		Module:    "core",
		Class:     "Num",
		Method:    "floor",
		Signature: "floor",
		IsStatic:  false,
		Doc:       "Returns the largest integer <= this number.",
	},
	{
		Module:    "core",
		Class:     "Num",
		Method:    "isNan",
		Signature: "isNan",
		IsStatic:  false,
		Doc:       "Returns true if this is NaN.",
	},
	{
		Module:    "core",
		Class:     "Num",
		Method:    "toString",
		Signature: "toString",
		IsStatic:  false,
		Doc:       "Converts the number to a string.",
	},`)

	// Write auto-generated modules
	for _, module := range modules {
		fmt.Fprintf(file, "\n\t// %s module (auto-generated)\n", module.ModuleName)
		for _, method := range module.Methods {
			fmt.Fprintf(file, "\t{\n")
			fmt.Fprintf(file, "\t\tModule:    \"%s\",\n", module.ModuleName)
			fmt.Fprintf(file, "\t\tClass:     \"%s\",\n", module.ClassName)
			fmt.Fprintf(file, "\t\tMethod:    \"%s\",\n", method.WrenName)
			fmt.Fprintf(file, "\t\tSignature: \"%s\",\n", method.Signature)
			fmt.Fprintf(file, "\t\tIsStatic:  %t,\n", method.IsStatic)
			fmt.Fprintf(file, "\t\tDoc:       \"%s\",\n", method.Doc)
			fmt.Fprintf(file, "\t},\n")
		}
	}

	fmt.Fprintln(file, "}")
}